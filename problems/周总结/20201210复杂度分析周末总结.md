


<p align="center">
  <a href="https://mp.weixin.qq.com/s/QVF6upVMSbgvZy8lHZS3CQ"><img src="https://img.shields.io/badge/知识星球-代码随想录-blue" alt=""></a>
  <a href="https://mp.weixin.qq.com/s/b66DFkOp8OOxdZC_xLZxfw"><img src="https://img.shields.io/badge/刷题-微信群-green" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201210231711160.png"><img src="https://img.shields.io/badge/公众号-代码随想录-brightgreen" alt=""></a>
  <a href="https://space.bilibili.com/525438321"><img src="https://img.shields.io/badge/B站-代码随想录-orange" alt=""></a>
</p>


正好也给「算法汇总」添加一个新专题-算法性能分析，以后如果有空余时间还会陆续更新这个模块，大家如果经常看「算法汇总」的话，就会发现，「算法汇总」里已经更新的三个模块「编程素养」「求职」「算法性能分析」，内容越来越丰满了，大家现在就可以去看看哈。

后面在算法题目之余，我还会继续更新这几个模块的！

# 周一

在[程序员的简历应该这么写！！（附简历模板）](https://programmercarl.com/前序/程序员简历.html)中以我自己的总结经验为例讲一讲大家应该如何写简历。

主要有如下几点：

* 简历篇幅不要过长
* 谨慎使用“精通”
* 拿不准的绝对不要写在简历上
* 项目经验中要突出自己的贡献
* 面试中如何变被动为主动
* 博客的重要性

最后还给出我自己的简历模板。

每一个点我都在文章中详细讲解了应该怎么写，平时应该如何积累，以及面前如何准备。

如果大家把以上几点都注意到了，那就是一份优秀的简历了，至少简历上就没啥毛病，剩下的就看自己的技术功底和临场发挥了。

一些录友会问我学校不好怎么办，没有项目经验怎么办之类的问题。

其实这就不在简历技巧的范围内了。

对于学校的话，某些公司可能有硬性要求，但如果能力特别出众，机会也是很大的。 不过说实话，大家都是普通人，真正技术能力出众的选手毕竟是少数。

**而且面试其实挺看缘分的**，相信大家应该都遇到过这种情景：同一家公司面别人的时候问题贼简单，然后人家就顺利拿offer，一到自己面的时候难题就上来了。

至于项目经验，没有项目，就要自己找找项目来做。

我的Github上有一些我曾经写过的一些小项目，大家可以去看看：https://github.com/youngyangyang04

**最后就是要端正写简历的心态，写简历是在自己真实背景和水平下，把自己各个方面包装到极致！**


# 周二

在[关于时间复杂度，你不知道的都在这里！](https://programmercarl.com/前序/关于时间复杂度，你不知道的都在这里！.html)中详细讲解了时间复杂度，很多被大家忽略的内容，在文中都做了详细的解释。

文中涉及如下问题：

* 究竟什么是大O？大O表示什么意思？严格按照大O的定义来说，快排应该是$O(n^2)$的算法！
* $O(n^2)$的算法为什么有时候比$O(n)$的算法更优？
* 什么时间复杂度为什么可以忽略常数项？
* 如何简化复杂的时间复杂度表达式，原理是什么？
* $O(\log n)$中的log究竟是以谁为底？

这些问题大家可能懵懵懂懂的了解一些，但一细问又答不上来。

相信看完本篇[关于时间复杂度，你不知道的都在这里！](https://programmercarl.com/前序/关于时间复杂度，你不知道的都在这里！.html)，以上问题大家就理解的清晰多了。

文中最后还运用以上知识通过一道简单的题目具体分析了一下其时间复杂度，给出两种方法究竟谁最优。

可以说从理论到实战将时间复杂度讲的明明白白。


# 周三

在[$O(n)$的算法居然超时了，此时的n究竟是多大？](https://programmercarl.com/前序/On的算法居然超时了，此时的n究竟是多大？.html)中介绍了大家在leetcode上提交代码经常遇到的一个问题-超时！

估计很多录友知道算法超时了，但没有注意过 $O(n)$的算法，如果1s内出结果，这个n究竟是多大？

文中从计算机硬件出发，分析计算机的计算性能，然后亲自做实验，整理出数据如下：

![程序超时1](https://img-blog.csdnimg.cn/20201208231559175.png)

**大家有一个数量级上的概念就可以了！**

正如文中说到的，**作为一名合格的程序员，至少要知道我们的程序是1s后出结果还是一年后出结果**。


# 周四

在[通过一道面试题目，讲一讲递归算法的时间复杂度！](https://programmercarl.com/前序/通过一道面试题目，讲一讲递归算法的时间复杂度！.html)中，讲一讲如果计算递归算法的时间复杂度。

递归的时间复杂度等于**递归的次数 * 每次递归中的操作次数**。

所以了解究竟递归了多少次就是重点。

文中通过一道简单的面试题：求x的n次方（**注意：这道面试题大厂面试官经常用！**），还原面试场景，来带大家深入了解一下递归的时间复杂度。

文中给出了四个版本的代码实现，并逐一分析了其时间复杂度。

此时大家就会发现，同一道题目，同样使用递归算法，有的同学会写出了$O(n)$的代码，有的同学就写出了$O(\log n)$的代码。

其本质是要对递归的时间复杂度有清晰的认识，才能运用递归来有效的解决问题！

相信看了本篇之后，对递归的时间复杂度分析就已经有深刻的理解了。


# 总结

本周讲解的内容都是经常被大家忽略的知识点，而通常这种知识点，才最能发现一位候选人的编程功底。

因为之前一直都是在持续更新算法题目的文章，这周说一说算法性能分析，感觉也是换了换口味，哈哈。

同时大家也会发现，**大厂面试官最喜欢用“简单题”（就是看起来很简单，其实非常考验技术功底的题目），而不是要手撕红黑树之类的**。

所以基础很重要，本周我介绍的内容其实都不难，看过的话都懂了，都是基础内容，但很多同学都把这些内容忽略掉了。

这其实也正常，咱们上学的时候教科书上基本没有实用的重点，而一般求职算法书也不讲这些，所以这方面内容可以靠看「代码随想录」的文章，当然更要靠自己多琢磨，多专研，多实践！

**下周开始恢复贪心题目系列**，后序有空我还会陆续讲一讲类似本周的基础内容，在「算法汇总」的那几个模块都会持续更新的。

就酱，「代码随想录」是技术公众号里的一抹清流，值得推荐给身边的朋友同学们！


<div align="center"><img src=https://code-thinking.cdn.bcebos.com/pics/01二维码.jpg width=450> </img></div>
