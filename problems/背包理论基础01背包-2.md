
## 滚动数组

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 

这里其实可以发现如果把dp[i-1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量，一定要时刻记住这里i和j的含义，要不然很容易看懵了。

**与其把dp[i-1]这一层拷贝到dp[i]上，不如只用一个一维数组了**。

只用dp[j]！（一维数组，也可以理解是一个滚动数组）

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]

* 一维dp数组如何初始化 

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

在回顾一下dp数组的含义：容量为j的背包，所背的物品价值可以最大为dp[j]。

那么dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。


* 一维dp数组的递推公式

dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

dp[j]可以通过dp[j - weight[j]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i体积 的背包 加上 物品i的价值。

那么最大的dp[j]可能就是 dp[j - weight[i]] + value[i]。

那么此时dp[j]有两个选择，一个是取自己dp[j]，一个是取dp[j - weight[i]] + value[i]，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。

* 一维dp数组遍历顺序 

代码如下： 

```
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！** 

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

为什么呢？ 

**倒叙遍历是为了保证物品i只被放入一次！**，在上面讲解二维dp遍历第0行的时候已经提到过一次。 

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15 

dp[2] = dp[2 - weight[0]] + value[0] = 30 

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？ 

倒叙就是先算dp[2] 

dp[2] = dp[2 - weight[0]] + value[0] = 15  （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15 

通过这个例子大家应该理解了为什么倒叙遍历可以保证数组只放入一次！

**那么问题又来了，为什么二维dp遍历的时候不用倒叙呢？**

因为对数二维dp，dp[i][j]都是通过上一层即dp[i-1][j]计算而来，不用考虑重复计算dp[i][j]的问题！


再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先背包容量嵌套遍历物品呢？

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，dp[bagWeight]只会放入一个物品。

一维dp01背包完整测试代码如下：

```
void test_1_wei_bag_problem() {
    int w[] = {1, 3, 4};
    int v[] = {15, 20, 30};
    int bagWeight = 4;
    vector<int> weight(w, w + sizeof(w)/sizeof(int));
    vector<int> value(v, v + sizeof(v)/sizeof(int));
    int dp[6] = {0};
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        // 把dp数组打印出来，看看对不对
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    // 输出结果
    cout << dp[bagWeight] << endl;
}

```
