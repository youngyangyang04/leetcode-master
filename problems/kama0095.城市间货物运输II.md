
# 95. 城市间货物运输 II 

[题目链接](https://kamacoder.com/problempage.php?pid=1153)

【题目描述】

某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。

网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；

权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。

然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：图中可能出现负权回路。

负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。

为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。

请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。

城市 1 到城市 n 之间可能会出现没有路径的情况

【输入描述】

第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。

接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。

【输出描述】

如果没有发现负权回路，则输出一个整数，表示从城市 1 到城市 n 的最低运输成本（包括政府补贴）。

如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 "circle"。如果从城市 1 无法到达城市 n，则输出 "unconnected"。


输入示例

```
4 4
1 2 -1
2 3 1
3 1 -1
3 4 1
```

输出示例

```
circle
```

## 思路 

本题是 [kama94.城市间货物运输I](./kama94.城市间货物运输I.md) 延伸题目。 

本题是要我们判断 负权回路，也就是图中出现环且环上的边总权值为负数。

如果在这样的图中求最短路的话， 就会在这个环里无限循环 （也是负数+负数 只会越来越小），无法求出最短路径。 

所以对于 在有负权值的图中求最短路，都需要先看看这个图里有没有负权回路。 

接下来我们来看 如何使用 bellman_ford 算法来判断 负权回路。 

在 [kama94.城市间货物运输I](./kama94.城市间货物运输I.md) 中 我们讲了 bellman_ford 算法的核心就是一句话：对 所有边 进行 n-1 次松弛。 同时文中的 【拓展】部分， 我们也讲了 松弛n次以上 会怎么样？ 

在没有负权回路的图中，松弛 n 次以上 ，结果不会有变化。 

但本题有 负权回路，如果松弛 n 次，结果就会有变化了，因为 有负权回路 就是可以无限最短路径（一直绕圈，就可以一直得到无限小的最短距离）。 

那么每松弛一次，都会更新最短路径，所以结果会一直有变化。

（如果对于 bellman_ford 不了解的录友，建议详细看这里：[kama94.城市间货物运输I](./kama94.城市间货物运输I.md)） 

以上为理论分析，接下来我们再画图举例。 

我们拿题目中示例来画一个图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20240402103135.png)  

图中 节点1 到 节点4 的最短路径是多少（题目中的最低运输成本） （注意边可以为负数的） 

节点1 -> 节点2 -> 节点3 -> 节点4，这样的路径总成本为 -1 + 1 + 1 = 1 

而图中有负权回路：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20240402103712.png) 

那么我们在负权回路中多绕一圈，我们的最短路径 是不是就更小了 （也就是更低的运输成本） 

节点1 -> 节点2 -> 节点3 -> 节点1 -> 节点2 -> 节点3 -> 节点4，这样的路径总成本 (-1) + 1 + (-1) +  (-1) + 1 + (-1) + 1 = -1  

如果在负权回路多绕两圈，三圈，无穷圈，那么我们的总成本就会无限小， 如果要求最小成本的话，你会发现本题就无解了。 

在 bellman_ford 算法中，松弛 n-1 次所有的边 就可以求得 起点到任何节点的最短路径，松弛 n 次以上，minDist数组（记录起到到其他节点的最短距离）中的结果也不会有改变 （如果对 bellman_ford 算法 不了解，也不知道 minDist 是什么，建议详看上篇讲解[kama94.城市间货物运输I](./kama94.城市间货物运输I.md)）  

而本题有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变。  

那么解决本题的 核心思路，就是在 [kama94.城市间货物运输I](./kama94.城市间货物运输I.md) 的基础上，再多松弛一次，看minDist数组 是否发生变化。

代码和 [kama94.城市间货物运输I](./kama94.城市间货物运输I.md) 基本是一样的，如下：（关键地方已注释） 

```CPP
#include <iostream>
#include <vector>
#include <list>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid;

    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid.push_back({p1, p2, val});

    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;
    bool flag = false;
    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路
        for (vector<int> &side : grid) {
            int from = side[0];
            int to = side[1];
            int price = side[2];
            if (i < n) {
                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;
            } else { // 多加一次松弛判断负权回路
                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;

            }
        }

    }

    if (flag) cout << "circle" << endl;
    else if (minDist[end] == INT_MAX) {
        cout << "unconnected" << endl;
    } else {
        cout << minDist[end] << endl;
    }
}
```

* 时间复杂度： O(N * E)  , N为节点数量，E为图中边的数量 
* 空间复杂度： O(N)  ，即 minDist 数组所开辟的空间
