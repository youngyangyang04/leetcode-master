<p align="center">
<a href="https://www.programmercarl.com/xunlian/xunlianying.html" target="_blank">
  <img src="../pics/è®­ç»ƒè¥.png" width="1000"/>
</a>
<p align="center"><strong><a href="./qita/join.md">å‚ä¸æœ¬é¡¹ç›®</a>ï¼Œè´¡çŒ®å…¶ä»–è¯­è¨€ç‰ˆæœ¬çš„ä»£ç ï¼Œæ‹¥æŠ±å¼€æºï¼Œè®©æ›´å¤šå­¦ä¹ ç®—æ³•çš„å°ä¼™ä¼´ä»¬å—ç›Šï¼</strong></p>


# 98.éªŒè¯äºŒå‰æœç´¢æ ‘

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/validate-binary-search-tree/)


ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

å‡è®¾ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å…·æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š

* èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
* èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
* æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

![98.éªŒè¯äºŒå‰æœç´¢æ ‘](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000750.png)

## ç®—æ³•å…¬å¼€è¯¾

**[ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾](https://programmercarl.com/other/gongkaike.html)ï¼š[ä½ å¯¹äºŒå‰æœç´¢æ ‘äº†è§£çš„è¿˜ä¸å¤Ÿï¼ | LeetCodeï¼š98.éªŒè¯äºŒå‰æœç´¢æ ‘](https://www.bilibili.com/video/BV18P411n7Q4)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚


## æ€è·¯

è¦çŸ¥é“ä¸­åºéå†ä¸‹ï¼Œè¾“å‡ºçš„äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹çš„æ•°å€¼æ˜¯æœ‰åºåºåˆ—ã€‚

æœ‰äº†è¿™ä¸ªç‰¹æ€§ï¼Œ**éªŒè¯äºŒå‰æœç´¢æ ‘ï¼Œå°±ç›¸å½“äºå˜æˆäº†åˆ¤æ–­ä¸€ä¸ªåºåˆ—æ˜¯ä¸æ˜¯é€’å¢çš„äº†ã€‚**

### é€’å½’æ³•

å¯ä»¥é€’å½’ä¸­åºéå†å°†äºŒå‰æœç´¢æ ‘è½¬å˜æˆä¸€ä¸ªæ•°ç»„ï¼Œä»£ç å¦‚ä¸‹ï¼š

```CPP
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
    traversal(root->right);
}
```

ç„¶ååªè¦æ¯”è¾ƒä¸€ä¸‹ï¼Œè¿™ä¸ªæ•°ç»„æ˜¯å¦æ˜¯æœ‰åºçš„ï¼Œ**æ³¨æ„äºŒå‰æœç´¢æ ‘ä¸­ä¸èƒ½æœ‰é‡å¤å…ƒç´ **ã€‚

```CPP
traversal(root);
for (int i = 1; i < vec.size(); i++) {
    // æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
    if (vec[i] <= vec[i - 1]) return false;
}
return true;
```

æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
private:
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
        traversal(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear(); // ä¸åŠ è¿™å¥åœ¨leetcodeä¸Šä¹Ÿå¯ä»¥è¿‡ï¼Œä½†æœ€å¥½åŠ ä¸Š
        traversal(root);
        for (int i = 1; i < vec.size(); i++) {
            // æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬æŠŠäºŒå‰æ ‘è½¬å˜ä¸ºæ•°ç»„æ¥åˆ¤æ–­ï¼Œæ˜¯æœ€ç›´è§‚çš„ï¼Œä½†å…¶å®ä¸ç”¨è½¬å˜æˆæ•°ç»„ï¼Œå¯ä»¥åœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­ç›´æ¥åˆ¤æ–­æ˜¯å¦æœ‰åºã€‚


è¿™é“é¢˜ç›®æ¯”è¾ƒå®¹æ˜“é™·å…¥ä¸¤ä¸ªé™·é˜±ï¼š

* é™·é˜±1

**ä¸èƒ½å•çº¯çš„æ¯”è¾ƒå·¦èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹å°±å®Œäº‹äº†**ã€‚

å†™å‡ºäº†ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š

```CPP
if (root->val > root->left->val && root->val < root->right->val) {
    return true;
} else {
    return false;
}
```

**æˆ‘ä»¬è¦æ¯”è¾ƒçš„æ˜¯ å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹**ã€‚æ‰€ä»¥ä»¥ä¸Šä»£ç çš„åˆ¤æ–­é€»è¾‘æ˜¯é”™è¯¯çš„ã€‚

ä¾‹å¦‚ï¼š [10,5,15,null,null,6,20] è¿™ä¸ªcaseï¼š

![äºŒå‰æœç´¢æ ‘](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000824.png)

èŠ‚ç‚¹10å¤§äºå·¦èŠ‚ç‚¹5ï¼Œå°äºå³èŠ‚ç‚¹15ï¼Œä½†å³å­æ ‘é‡Œå‡ºç°äº†ä¸€ä¸ª6 è¿™å°±ä¸ç¬¦åˆäº†ï¼

* é™·é˜±2

æ ·ä¾‹ä¸­æœ€å°èŠ‚ç‚¹ å¯èƒ½æ˜¯intçš„æœ€å°å€¼ï¼Œå¦‚æœè¿™æ ·ä½¿ç”¨æœ€å°çš„intæ¥æ¯”è¾ƒä¹Ÿæ˜¯ä¸è¡Œçš„ã€‚

æ­¤æ—¶å¯ä»¥åˆå§‹åŒ–æ¯”è¾ƒå…ƒç´ ä¸ºlonglongçš„æœ€å°å€¼ã€‚

é—®é¢˜å¯ä»¥è¿›ä¸€æ­¥æ¼”è¿›ï¼šå¦‚æœæ ·ä¾‹ä¸­æ ¹èŠ‚ç‚¹çš„val å¯èƒ½æ˜¯longlongçš„æœ€å°å€¼ åˆè¦æ€ä¹ˆåŠå‘¢ï¼Ÿæ–‡ä¸­ä¼šè§£ç­”ã€‚

äº†è§£è¿™äº›é™·é˜±ä¹‹åæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä»£ç åº”è¯¥æ€ä¹ˆå†™ï¼š

é€’å½’ä¸‰éƒ¨æ›²ï¼š

* ç¡®å®šé€’å½’å‡½æ•°ï¼Œè¿”å›å€¼ä»¥åŠå‚æ•°

è¦å®šä¹‰ä¸€ä¸ªlonglongçš„å…¨å±€å˜é‡ï¼Œç”¨æ¥æ¯”è¾ƒéå†çš„èŠ‚ç‚¹æ˜¯å¦æœ‰åºï¼Œå› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼ï¼Œæ‰€ä»¥å®šä¹‰ä¸ºlonglongçš„ç±»å‹ï¼Œåˆå§‹åŒ–ä¸ºlonglongæœ€å°å€¼ã€‚

æ³¨æ„é€’å½’å‡½æ•°è¦æœ‰boolç±»å‹çš„è¿”å›å€¼ï¼Œ æˆ‘ä»¬åœ¨[äºŒå‰æ ‘ï¼šé€’å½’å‡½æ•°ç©¶ç«Ÿä»€ä¹ˆæ—¶å€™éœ€è¦è¿”å›å€¼ï¼Œä»€ä¹ˆæ—¶å€™ä¸è¦è¿”å›å€¼ï¼Ÿ](https://programmercarl.com/0112.è·¯å¾„æ€»å’Œ.html) ä¸­è®²äº†ï¼Œåªæœ‰å¯»æ‰¾æŸä¸€æ¡è¾¹ï¼ˆæˆ–è€…ä¸€ä¸ªèŠ‚ç‚¹ï¼‰çš„æ—¶å€™ï¼Œé€’å½’å‡½æ•°ä¼šæœ‰boolç±»å‹çš„è¿”å›å€¼ã€‚

å…¶å®æœ¬é¢˜æ˜¯åŒæ ·çš„é“ç†ï¼Œæˆ‘ä»¬åœ¨å¯»æ‰¾ä¸€ä¸ªä¸ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿™ä¸ªèŠ‚ç‚¹å°±éå†äº†æ•´ä¸ªæ ‘ï¼Œå¦‚æœæ‰¾åˆ°ä¸ç¬¦åˆçš„èŠ‚ç‚¹äº†ï¼Œç«‹åˆ»è¿”å›ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```CPP
long long maxVal = LONG_MIN; // å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼
bool isValidBST(TreeNode* root)
```

* ç¡®å®šç»ˆæ­¢æ¡ä»¶

å¦‚æœæ˜¯ç©ºèŠ‚ç‚¹ æ˜¯ä¸æ˜¯äºŒå‰æœç´¢æ ‘å‘¢ï¼Ÿ

æ˜¯çš„ï¼ŒäºŒå‰æœç´¢æ ‘ä¹Ÿå¯ä»¥ä¸ºç©ºï¼

ä»£ç å¦‚ä¸‹ï¼š

```CPP
if (root == NULL) return true;
```

* ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘

ä¸­åºéå†ï¼Œä¸€ç›´æ›´æ–°maxValï¼Œä¸€æ—¦å‘ç°maxVal >= root->valï¼Œå°±è¿”å›falseï¼Œæ³¨æ„å…ƒç´ ç›¸åŒæ—¶å€™ä¹Ÿè¦è¿”å›falseã€‚

ä»£ç å¦‚ä¸‹ï¼š

```CPP
bool left = isValidBST(root->left);         // å·¦

// ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
if (maxVal < root->val) maxVal = root->val; // ä¸­
else return false;

bool right = isValidBST(root->right);       // å³
return left && right;
```

æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    long long maxVal = LONG_MIN; // å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

ä»¥ä¸Šä»£ç æ˜¯å› ä¸ºåå°æ•°æ®æœ‰intæœ€å°å€¼æµ‹è¯•ç”¨ä¾‹ï¼Œæ‰€ä»¥éƒ½æŠŠmaxValæ”¹æˆäº†longlongæœ€å°å€¼ã€‚

å¦‚æœæµ‹è¯•æ•°æ®ä¸­æœ‰ longlongçš„æœ€å°å€¼ï¼Œæ€ä¹ˆåŠï¼Ÿ

ä¸å¯èƒ½åœ¨åˆå§‹åŒ–ä¸€ä¸ªæ›´å°çš„å€¼äº†å§ã€‚ å»ºè®®é¿å… åˆå§‹åŒ–æœ€å°å€¼ï¼Œå¦‚ä¸‹æ–¹æ³•å–åˆ°æœ€å·¦é¢èŠ‚ç‚¹çš„æ•°å€¼æ¥æ¯”è¾ƒã€‚

ä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    TreeNode* pre = NULL; // ç”¨æ¥è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

æœ€åè¿™ä»½ä»£ç çœ‹ä¸Šå»æ•´æ´ä¸€äº›ï¼Œæ€è·¯ä¹Ÿæ¸…æ™°ã€‚

### è¿­ä»£æ³•

å¯ä»¥ç”¨è¿­ä»£æ³•æ¨¡æ‹ŸäºŒå‰æ ‘ä¸­åºéå†ï¼Œå¯¹å‰ä¸­ååºè¿­ä»£æ³•ç”Ÿç–çš„åŒå­¦å¯ä»¥çœ‹è¿™ä¸¤ç¯‡[äºŒå‰æ ‘ï¼šå¬è¯´é€’å½’èƒ½åšçš„ï¼Œæ ˆä¹Ÿèƒ½åšï¼](https://programmercarl.com/äºŒå‰æ ‘çš„è¿­ä»£éå†.html)ï¼Œ[äºŒå‰æ ‘ï¼šå‰ä¸­ååºè¿­ä»£æ–¹å¼ç»Ÿä¸€å†™æ³•](https://programmercarl.com/äºŒå‰æ ‘çš„ç»Ÿä¸€è¿­ä»£æ³•.html)

è¿­ä»£æ³•ä¸­åºéå†ç¨åŠ æ”¹åŠ¨å°±å¯ä»¥äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š

```CPP
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // å·¦
            } else {
                cur = st.top();                 // ä¸­
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //ä¿å­˜å‰ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹

                cur = cur->right;               // å³
            }
        }
        return true;
    }
};
```

åœ¨[äºŒå‰æ ‘ï¼šäºŒå‰æœç´¢æ ‘ç™»åœºï¼](https://programmercarl.com/0700.äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢.html)ä¸­æˆ‘ä»¬åˆ†æ˜å†™å‡ºäº†ç—›å“­æµæ¶•çš„ç®€æ´è¿­ä»£æ³•ï¼Œæ€ä¹ˆåœ¨è¿™é‡Œä¸è¡Œäº†å‘¢ï¼Œå› ä¸ºæœ¬é¢˜æ˜¯è¦éªŒè¯äºŒå‰æœç´¢æ ‘å•Šã€‚

## æ€»ç»“

è¿™é“é¢˜ç›®æ˜¯ä¸€ä¸ªç®€å•é¢˜ï¼Œä½†å¯¹äºæ²¡æ¥è§¦è¿‡çš„åŒå­¦è¿˜æ˜¯æœ‰éš¾åº¦çš„ã€‚

æ‰€ä»¥åˆå­¦è€…åˆšå¼€å§‹å­¦ä¹ ç®—æ³•çš„æ—¶å€™ï¼Œçœ‹åˆ°ç®€å•é¢˜ç›®æ²¡æœ‰æ€è·¯å¾ˆæ­£å¸¸ï¼Œåƒä¸‡åˆ«æ€€ç–‘è‡ªå·±æ™ºå•†ï¼Œå­¦ä¹ è¿‡ç¨‹éƒ½æ˜¯è¿™æ ·çš„ï¼Œå¤§å®¶æ™ºå•†éƒ½å·®ä¸å¤šã€‚

åªè¦æŠŠåŸºæœ¬ç±»å‹çš„é¢˜ç›®éƒ½åšè¿‡ï¼Œæ€»ç»“è¿‡ä¹‹åï¼Œæ€è·¯è‡ªç„¶å°±å¼€é˜”äº†ï¼ŒåŠ æ²¹ğŸ’ª 


## å…¶ä»–è¯­è¨€ç‰ˆæœ¬


### Java 

```Java
//ä½¿ç”¨çµ±ä¸€è¿­ä»£æ³•
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        if(root != null)
            stack.add(root);        
        while(!stack.isEmpty()){
            TreeNode curr = stack.peek();
            if(curr != null){
                stack.pop();
                if(curr.right != null)
                    stack.add(curr.right);
                stack.add(curr);
                stack.add(null);
                if(curr.left != null)
                    stack.add(curr.left);
            }else{
                stack.pop();
                TreeNode temp = stack.pop();
                if(pre != null && pre.val >= temp.val)
                    return false;
                pre = temp;
            }
        }
        return true;
    }
}
```
```Java
class Solution {
    // é€’å½’
    TreeNode max;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // å·¦
        boolean left = isValidBST(root.left);
        if (!left) {
            return false;
        }
        // ä¸­
        if (max != null && root.val <= max.val) {
            return false;
        }
        max = root;
        // å³
        boolean right = isValidBST(root.right);
        return right;
    }
}

class Solution {
    // è¿­ä»£
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// å·¦
            }
            // ä¸­ï¼Œå¤„ç†
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }
            pre = pop;

            root = pop.right;// å³
        }
        return true;
    }
}

// ç®€æ´å®ç°Â·é€’å½’è§£æ³•
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);
    }
    boolean validBST(long lower, long upper, TreeNode root) {
        if (root == null) return true;
        if (root.val <= lower || root.val >= upper) return false;
        return validBST(lower, root.val, root.left) && validBST(root.val, upper, root.right);
    }
}
// ç®€æ´å®ç°Â·ä¸­åºéå†
class Solution {
    private long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }
        if (root.val <= prev) { // ä¸æ»¡è¶³äºŒå‰æœç´¢æ ‘æ¡ä»¶
            return false;
        }
        prev = root.val;
        return isValidBST(root.right);
    }
}
```

### Python 

é€’å½’æ³•ï¼ˆç‰ˆæœ¬ä¸€ï¼‰åˆ©ç”¨ä¸­åºé€’å¢æ€§è´¨ï¼Œè½¬æ¢æˆæ•°ç»„
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.vec = []

    def traversal(self, root):
        if root is None:
            return
        self.traversal(root.left)
        self.vec.append(root.val)  # å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
        self.traversal(root.right)

    def isValidBST(self, root):
        self.vec = []  # æ¸…ç©ºæ•°ç»„
        self.traversal(root)
        for i in range(1, len(self.vec)):
            # æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
            if self.vec[i] <= self.vec[i - 1]:
                return False
        return True

```

é€’å½’æ³•ï¼ˆç‰ˆæœ¬äºŒï¼‰è®¾å®šæå°å€¼ï¼Œè¿›è¡Œæ¯”è¾ƒ

```python
class Solution:
    def __init__(self):
        self.maxVal = float('-inf')  # å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)
        # ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
        if self.maxVal < root.val:
            self.maxVal = root.val
        else:
            return False
        right = self.isValidBST(root.right)

        return left and right

```
é€’å½’æ³•ï¼ˆç‰ˆæœ¬ä¸‰ï¼‰ç›´æ¥å–è¯¥æ ‘çš„æœ€å°å€¼
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.pre = None  # ç”¨æ¥è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)

        if self.pre is not None and self.pre.val >= root.val:
            return False
        self.pre = root  # è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

        right = self.isValidBST(root.right)
        return left and right



```
è¿­ä»£æ³•
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root):
        stack = []
        cur = root
        pre = None  # è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        while cur is not None or len(stack) > 0:
            if cur is not None:
                stack.append(cur)
                cur = cur.left  # å·¦
            else:
                cur = stack.pop()  # ä¸­
                if pre is not None and cur.val <= pre.val:
                    return False
                pre = cur  # ä¿å­˜å‰ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹
                cur = cur.right  # å³
        return True

```


### Go

```Go
func isValidBST(root *TreeNode) bool {
	// äºŒå‰æœç´¢æ ‘ä¹Ÿå¯ä»¥æ˜¯ç©ºæ ‘
    if root == nil {
        return true
    }
    // ç”±é¢˜ç›®ä¸­çš„æ•°æ®é™åˆ¶å¯ä»¥å¾—å‡ºminå’Œmax
    return check(root,math.MinInt64,math.MaxInt64)
}

func check(node *TreeNode,min,max int64) bool {
    if node == nil {
        return true
    }

    if min >= int64(node.Val) || max <= int64(node.Val) {
        return false
    }
    // åˆ†åˆ«å¯¹å·¦å­æ ‘å’Œå³å­æ ‘é€’å½’åˆ¤æ–­ï¼Œå¦‚æœå·¦å­æ ‘å’Œå³å­æ ‘éƒ½ç¬¦åˆåˆ™è¿”å›true
    return check(node.Right,int64(node.Val),max) && check(node.Left,min,int64(node.Val))
}
```
```go
// ä¸­åºéå†è§£æ³•
func isValidBST(root *TreeNode) bool {
    // ä¿å­˜ä¸Šä¸€ä¸ªæŒ‡é’ˆ
    var prev *TreeNode
    var travel func(node *TreeNode) bool
    travel = func(node *TreeNode) bool {
        if node == nil {
            return true
        }
        leftRes := travel(node.Left)
        // å½“å‰å€¼å°äºç­‰äºå‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œè¿”å›false
        if prev != nil && node.Val <= prev.Val {
            return false
        }
        prev = node
        rightRes := travel(node.Right)
        return leftRes && rightRes
    }
    return travel(root)
}
```

### JavaScript

è¾…åŠ©æ•°ç»„è§£å†³

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
    let arr = [];
    const buildArr = (root) => {
        if (root) {
            buildArr(root.left);
            arr.push(root.val);
            buildArr(root.right);
        }
    }
    buildArr(root);
    for (let i = 1; i < arr.length; ++i) {
        if (arr[i] <= arr[i - 1])
            return false;
    }
    return true;
};
```

é€’å½’ä¸­è§£å†³

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let pre = null;
var isValidBST = function (root) {
    let pre = null;
    const inOrder = (root) => {
        if (root === null)
            return true;
        let left = inOrder(root.left);

        if (pre !== null && pre.val >= root.val)
            return false;
        pre = root;

        let right = inOrder(root.right);
        return left && right;
    }
    return inOrder(root);
};
```

> è¿­ä»£æ³•:

```JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let pre = null;
var isValidBST = function (root) {
	const queue = [];
	let cur = root;
	let pre = null;
	while (cur !== null || queue.length !== 0) {
		if (cur !== null) {
			queue.push(cur);
			cur = cur.left;
		} else {
			cur = queue.pop();
			if (pre !== null && cur.val <= pre.val) {
				return false;
			}
			pre = cur;
			cur = cur.right;
		}
	}
	return true;
};
```

### TypeScript

> è¾…åŠ©æ•°ç»„è§£å†³ï¼š

```typescript
function isValidBST(root: TreeNode | null): boolean {
    const traversalArr: number[] = [];
    function inorderTraverse(root: TreeNode | null): void {
        if (root === null) return;
        inorderTraverse(root.left);
        traversalArr.push(root.val);
        inorderTraverse(root.right);
    }
    inorderTraverse(root);
    for (let i = 0, length = traversalArr.length; i < length - 1; i++) {
        if (traversalArr[i] >= traversalArr[i + 1]) return false;
    }
    return true;
};
```

> é€’å½’ä¸­è§£å†³ï¼š

```typescript
function isValidBST(root: TreeNode | null): boolean {
    let maxVal = -Infinity;
    function inorderTraverse(root: TreeNode | null): boolean {
        if (root === null) return true;
        let leftValid: boolean = inorderTraverse(root.left);
        if (!leftValid) return false;
        if (maxVal < root.val) {
            maxVal = root.val
        } else {
            return false;
        }
        let rightValid: boolean = inorderTraverse(root.right);
        return leftValid && rightValid;
    }
    return inorderTraverse(root);
};
```

> è¿­ä»£æ³•:

```TypeScript
function isValidBST(root: TreeNode | null): boolean {
	const queue: TreeNode[] = [];
	let cur: TreeNode | null = root;
	let pre: TreeNode | null = null;
	while (cur !== null || queue.length !== 0) {
		if (cur !== null) {
			queue.push(cur);
			cur = cur.left;
		} else {
			cur = queue.pop()!;
			if (pre !== null && cur!.val <= pre.val) {
				return false;
			}
			pre = cur;
			cur = cur!.right;
		}
	}
	return true;
}
```

### Scala

è¾…åŠ©æ•°ç»„è§£å†³:
```scala
object Solution {
  import scala.collection.mutable
  def isValidBST(root: TreeNode): Boolean = {
    var arr = new mutable.ArrayBuffer[Int]()
    // é€’å½’ä¸­åºéå†äºŒå‰æ ‘ï¼Œå°†èŠ‚ç‚¹æ·»åŠ åˆ°arr
    def traversal(node: TreeNode): Unit = {
      if (node == null) return
      traversal(node.left)
      arr.append(node.value)
      traversal(node.right)
    }
    traversal(root)
    // è¿™ä¸ªæ•°ç»„å¦‚æœæ˜¯å‡åºå°±ä»£è¡¨æ˜¯äºŒå‰æœç´¢æ ‘
    for (i <- 1 until arr.size) {
      if (arr(i) <= arr(i - 1)) return false
    }
    true  
  }
}
```

é€’å½’ä¸­è§£å†³:
```scala
object Solution {
  def isValidBST(root: TreeNode): Boolean = {
    var flag = true
    var preValue:Long = Long.MinValue // è¿™é‡Œè¦ä½¿ç”¨Longç±»å‹

    def traversal(node: TreeNode): Unit = {
      if (node == null || flag == false) return
      traversal(node.left)
      if (node.value > preValue) preValue = node.value
      else flag = false
      traversal(node.right)
    }
    traversal(root)
    flag  
  }
}
```

### Rust

é€’å½’ï¼š

```rust
impl Solution {
    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        Self::valid_bst(i64::MIN, i64::MAX, root)
    }
    pub fn valid_bst(low: i64, upper: i64, root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        if root.is_none() {
            return true;
        }
        let root = root.as_ref().unwrap().borrow();
        if root.val as i64 <= low || root.val as i64 >= upper {
            return false;
        }
        Self::valid_bst(low, root.val as i64, root.left.clone())
            && Self::valid_bst(root.val as i64, upper, root.right.clone())
    }
}
```

è¾…åŠ©æ•°ç»„ï¼š

```rust
impl Solution {
    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        let mut vec = vec![];
        Self::valid_bst(root, &mut vec);
        for i in 1..vec.len() {
            if vec[i] <= vec[i - 1] {
                return false;
            }
        }
        true
    }
    pub fn valid_bst(root: Option<Rc<RefCell<TreeNode>>>, mut v: &mut Vec<i64>) {
        if root.is_none() {
            return;
        }
        let node = root.as_ref().unwrap().borrow();
        Self::valid_bst(node.left.clone(), v);
        v.push(node.val as i64);
        Self::valid_bst(node.right.clone(), v);
    }
}
```
### C#
```csharp
// é€’å½’
public long val = Int64.MinValue;
public bool IsValidBST(TreeNode root)
{
    if (root == null) return true;
    bool left = IsValidBST(root.left);
    if (root.val > val) val = root.val;
    else return false;
    bool right = IsValidBST(root.right);
    return left && right;
}
```


<p align="center">
<a href="https://programmercarl.com/other/kstar.html" target="_blank">
  <img src="../pics/ç½‘ç«™æ˜Ÿçƒå®£ä¼ æµ·æŠ¥.jpg" width="1000"/>
</a>
